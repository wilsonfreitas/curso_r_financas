[
["index.html", "Tópicos de Finanças com R Boas-vindas Sobre os instrutores", " Tópicos de Finanças com R Sillas Gonzaga e Wilson Freitas 2020-11-19 Boas-vindas Blá-blá-blá Sobre os instrutores Sillas Gonzaga Sillas é sou apaixonado pelo R. Pratica essa linguagem desde 2014 e, desde então, criou o blog chamado Paixão por Dados, já ministrou palestras sobre sua carreira com R e já publicou 4 pacotes R. Wilson Freitas Wilson Freitas é pai, padeiro amador e corredor de rua. Profissionalmente trabalha como Quant (especialista em modelagem quantitativa em finanças) no mercado financeiro desde 2007, onde passou por diversas instituições (Itaú, B3, ModalMais, etc.). Gosta de programar quando não está correndo nem fazendo pão e sempre contribuiu com o software livre desenvolvendo pacotes para as linguagens de programação e escrevendo posts no seu blog. Mantém uma conta ativa no Github (@wilsonfreitas) com mais de 50 repositórios de sua autoria. "],
["intro.html", "Capítulo 1 Introduction", " Capítulo 1 Introduction You can label chapter and section titles using {#label} after them, e.g., we can reference Chapter 1. If you do not manually label them, there will be automatic labels anyway, e.g., Chapter 3. Figures and tables with captions will be placed in figure and table environments, respectively. par(mar = c(4, 4, .1, .1)) plot(pressure, type = &#39;b&#39;, pch = 19) Figure 1.1: Here is a nice figure! Reference a figure by its code chunk label with the fig: prefix, e.g., see Figure 1.1. Similarly, you can reference tables generated from knitr::kable(), e.g., see Table 1.1. knitr::kable( head(iris, 20), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 1.1: Here is a nice table! Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 5.4 3.7 1.5 0.2 setosa 4.8 3.4 1.6 0.2 setosa 4.8 3.0 1.4 0.1 setosa 4.3 3.0 1.1 0.1 setosa 5.8 4.0 1.2 0.2 setosa 5.7 4.4 1.5 0.4 setosa 5.4 3.9 1.3 0.4 setosa 5.1 3.5 1.4 0.3 setosa 5.7 3.8 1.7 0.3 setosa 5.1 3.8 1.5 0.3 setosa You can write citations, too. For example, we are using the bookdown package (Xie 2020) in this sample book, which was built on top of R Markdown and knitr (Xie 2015). References "],
["literature.html", "Capítulo 2 Literature", " Capítulo 2 Literature Here is a review of existing methods. "],
["methods.html", "Capítulo 3 Methods", " Capítulo 3 Methods We describe our methods in this chapter. "],
["returns.html", "Capítulo 4 Análise de Retornos 4.1 Retornos simples 4.2 Retornos logaritimicos 4.3 Relação entre os retornos simples e logaritimicos 4.4 Porque formas diferentes de calcular os retornos? 4.5 Retorno esperado 4.6 Risco esperado 4.7 Exercícios - Análise de Retornos", " Capítulo 4 Análise de Retornos Vamos considerar os seguintes investimentos em ações: Investimento em WEGE3 a R$ 42,03 em junho/2020 e venda em julho/2020 a R$ 67,32, lucro de R$ 25,29 por ação em 2 meses. Investimento em OIBR3 a R$ 0,49 em abril/2020 e venda em junho/2020 a R$ 1,20, lucro de R$ 0,71 por ação em 3 meses. Investimento em VVAR3 a R$ 4,65 em abril/2020 e venda em setembro/2020 a R$ 17,87, lucro de R$ 13,22 por ação em 6 meses. Qual investimento tem o melhor retorno? O investimento em WEGE3 apresenta o melhor resultado financeiro, pois é o que paga o maior retorno por ação, R$ 25,29. Calculando o resultado percentual temos 100 * c( WEGE3 = (67.32 - 42.03) / 42.03, OIBR3 = (1.20 - 0.49) / 0.49, VVAR3 = (17.87 - 4.65) / 4.65 ) ## WEGE3 OIBR3 VVAR3 ## 60.17131 144.89796 284.30108 O retorno percentual no período total da VVAR3 foi o dobro da OIBR3 e o quatro vezes o da WEGE3. Se ainda considerarmos o prazo do investimento de forma linear, ou seja, dividindo o retorno percentual pelo prazo em meses do investimento, temos: meses &lt;- c(2, 3, 6) 100 * c( WEGE3 = (67.32 - 42.03) / 42.03, OIBR3 = (1.20 - 0.49) / 0.49, VVAR3 = (17.87 - 4.65) / 4.65 ) / meses ## WEGE3 OIBR3 VVAR3 ## 30.08565 48.29932 47.38351 O retorno por mês da OIBR3 é um pouco maior que o retorno da VVAR3, na prática muito próximos. O que podemos extrair desses exemplos? Há diversas formas de avaliar o resultado entregue por um investimento: financeiro, percentual, ajustado ao prazo e outras formas. retorno é um termo utilizado para fazer referência ao resultado de um investimento. Veremos nas próximas seções algumas formas de calcular o retorno de um investimento e como utilizar o retorno para fazer a análise de risco do investimento. O que são retornos? Os retornos (retornos financeiros) representam a variação no preço dos nossos investimentos. Exemplo: Variação do preço de fechamento do ETF BOVA11 entre 31-01-2020 e 30-09-2020. getSymbols(&quot;BOVA11.SA&quot;, from = &quot;2020-01-31&quot;, to = &quot;2020-10-01&quot;) ## [1] &quot;BOVA11.SA&quot; Cl(BOVA11.SA)[c(&quot;2020-01-31&quot;, &quot;2020-09-30&quot;)] %&gt;% as.numeric() ## [1] 108.90 91.05 Vamos calcular a variação total dos preços usando a função diff Cl(BOVA11.SA)[c(&quot;2020-01-31&quot;, &quot;2020-09-30&quot;)] %&gt;% as.numeric() %&gt;% diff() ## [1] -17.85 Entre as datas 31-01-2020 e 30-09-2020 o cotação do BOVA11 perdeu R$ 17,85, pois temos uma variação negativa. Essa é a variação total, simplismente a diferença dos preços em instantes de tempo diferentes. Exemplo: Variação da cotação do Dólar Americano em Reais entre 31-01-2020 e 30-09-2020. USDBRL &lt;- get_currency(&quot;USD&quot;, start_date = &quot;2020-01-31&quot;, end_date = &quot;2020-10-01&quot;, as = &quot;xts&quot;) Ask(USDBRL)[c(&quot;2020-01-31&quot;, &quot;2020-09-30&quot;)] %&gt;% as.numeric() ## [1] 4.2695 5.6407 Vamos calcular a variação total dos preços usando a função diff Ask(USDBRL)[c(&quot;2020-01-31&quot;, &quot;2020-09-30&quot;)] %&gt;% as.numeric() %&gt;% diff() ## [1] 1.3712 Note que entre as datas 31-01-2020 e 30-09-2020 o cotação do Dólar Americano perdeu R$ 1,3712, pelo menos 1 ordem de grandeza menor que o BOVA11, em módulo. A variação total pode ser considerada uma medida de retorno, entretanto, ela está muito vinculada ao valor do ativo. Vamos considerar \\(P_t\\) o valor do ativo em um instante \\(t\\) qualquer. A variação deste ativo entre os instantes \\(t\\) e \\(t-1\\) é dada por: \\[ \\Delta P_t = P_t - P_{t-1} \\] Chamamos esta variação total de \\(\\Delta P_t\\) onde \\(t\\) representa um instante qualquer no tempo e \\(t-1\\) é o instante anterior na série. Em nosso exemplo \\(t\\) é a primeira data e \\(t-1\\) a segunda. Como observamos, no mesmo período, os dois ativos apresentam medidas muito diferentes, logo, com esta medida é difícil comparar os 2 ativos. Há duas formas de calcular os retornos de maneira que possamos comparar os investimentos. Retornos Simples: calculados a partir da variação percentual dos preços com referência ao valor inicial Retornos Logarítimicos: calculados a partir da variação do logarítimo dos preços Nas próximas seções vamos detalhar estes tipos de retornos e como calculá-los. 4.1 Retornos simples Os retornos simples são a variação percentual dos preços de um ativo. Do exemplo do BOVA11 temos a diferença dos preços nas datas 31-01-2020 e 30-09-2020. Cl(BOVA11.SA)[c(&quot;2020-01-31&quot;, &quot;2020-09-30&quot;)] %&gt;% as.numeric() %&gt;% diff() ## [1] -17.85 Dada a diferença, só precisamos dividir pelo preço inicial, na data 31-01-2020. diff_ &lt;- Cl(BOVA11.SA)[c(&quot;2020-01-31&quot;, &quot;2020-09-30&quot;)] %&gt;% as.numeric() %&gt;% diff() ini_price &lt;- Cl(BOVA11.SA)[&quot;2020-01-31&quot;] %&gt;% as.numeric() diff_ / ini_price ## [1] -0.1639118 O BOVA11 apresentou uma variação negativa de 16,39% no período. Usando os dados do Dólar Americano temos diff_ &lt;- Ask(USDBRL)[c(&quot;2020-01-31&quot;, &quot;2020-09-30&quot;)] %&gt;% as.numeric() %&gt;% diff() ini_price &lt;- Ask(USDBRL)[&quot;2020-01-31&quot;] %&gt;% as.numeric() diff_ / ini_price ## [1] 0.3211617 O Dólar Americano apresentou uma variação positiva de 32,11% no período, aproximadamente o dobro da variação do BOVA11, em módulo. Colocando em equação, a variação percentual é dada pela divisão de \\(\\Delta P_t\\) pelo seu valor inicial, \\(P_{t-1}\\), dessa forma calculamos o retorno simples \\(R_t\\). \\[\\begin{equation} R_t = \\frac{\\Delta P_t}{P_{t-1}} = \\frac{P_t - P_{t-1}}{P_{t-1}} = \\frac{P_t}{P_{t-1}} - 1 \\tag{4.1} \\end{equation}\\] O cálculo do retorno simples para dois instantes de tempo é útil para cálculos isolados, na prática queremos calcular retornos compostos em diferentes períodos em sequência. Queremos responder a perguntas como: Para uma série de preços diários de um ativo, calculamos os retornos simples diários, qual é a média dos retornos diários no período? Para uma série de retornos diários de um ativo, como calcular o retorno mensal? Dado o retorno mensal, qual é o retorno médio diário? 4.1.1 Retornos Simples Multiperíodo Vamos calcular os retornos simples a partir de uma série de preços. Com uma série temporal no R calculamos a variação usando a função diff para a série do Dólar Americano entre as datas 01-09-2020 e 04-09-2020. USDBRL &lt;- get_currency(&quot;USD&quot;, start_date = &quot;2020-09-01&quot;, end_date = &quot;2020-09-04&quot;, as = &quot;xts&quot;) %&gt;% Ask() merge( USDBRL %&gt;% setNames(&quot;P_t&quot;), diff(USDBRL) %&gt;% setNames(&quot;diff&quot;) ) ## P_t diff ## 2020-09-01 5.3732 NA ## 2020-09-02 5.3741 0.0009 ## 2020-09-03 5.3079 -0.0662 ## 2020-09-04 5.2848 -0.0231 O primeiro elemento do vetor de diferenças é um NA porque o cálculo das diferenças é entre o elemento corrente com o anterior e para o primeiro elemento não há um elemento anterior para realizar o cálculo, dessa forma o R mantém a estrutura de índices e indica que o resultado para o índice em questão não está disponível. Usamos setNames para renomear diff(USDBRL) que vem com o nome ask, que é o mesmo da série original. Isso é interessante e uma ótima alternativa para organizar a apresentação dos dados. Usamos também a função merge para juntar as séries de preço e diferenças. A série diff é a série de diferenças, logo, representa \\(\\Delta P_t\\). Para realizar este cálculo de \\(R_t\\) no R é necessário obter a série de \\(P_{t-1}\\). Isso pode ser feito com a função lag.xts da série temporal. merge( USDBRL %&gt;% setNames(&quot;P_t&quot;), lag.xts(USDBRL) %&gt;% setNames(&quot;P_t1&quot;), diff(USDBRL) %&gt;% setNames(&quot;diff&quot;) ) ## P_t P_t1 diff ## 2020-09-01 5.3732 NA NA ## 2020-09-02 5.3741 5.3732 0.0009 ## 2020-09-03 5.3079 5.3741 -0.0662 ## 2020-09-04 5.2848 5.3079 -0.0231 Note que essa função desloca a série tempora em 1 elemento adiante. Aqui a coluna P_t1 refere-se a \\(P_{t-1}\\). Uma boa forma de ler esse resultado é que em \\(t\\) igual a 2020-09-02, \\(P_{t-1}\\) é 5.3732, que é o valor de \\(P_t\\) quando \\(t\\) é 2020-09-01, ou seja, o instante anterior. Assim, o retorno \\(R_t\\) é calculado no R da seguinte maneira: (100 * diff(USDBRL) / lag.xts(USDBRL)) %&gt;% setNames(&quot;R_t&quot;) ## R_t ## 2020-09-01 NA ## 2020-09-02 0.0167498 ## 2020-09-03 -1.2318342 ## 2020-09-04 -0.4352004 Note a multiplicação por 100 no código R, isso ajuda a interpretar o resultado. De forma prática observamos que do segundo para o terceiro dia tivemos um retorno negativo de mais de 1% na cotação do dólar, por exemplo. Uma outra forma de calcular retornos simples é utilizando a função Return.calculate do pacote PerformanceAnalytics. 100 * Return.calculate(USDBRL, method = &quot;discrete&quot;) %&gt;% setNames(&quot;R_t&quot;) ## R_t ## 2020-09-01 NA ## 2020-09-02 0.0167498 ## 2020-09-03 -1.2318342 ## 2020-09-04 -0.4352004 Dessa forma calculamos os retornos simples para uma série temporal. Neste exemplo calculamos os retornos diários, pois a série é de cotações diárias. É comum trabalharmos com séries com períodos maiores como séries semanais, mensais ou anuais. Logo, utilizando ainda a série do Dólar Americano, vamos obter a série mensal de preços e desta série vamos obter a série de retornos mensais para o ano de 2019. USDBRL_2019 &lt;- get_currency(&quot;USD&quot;, start_date = &quot;2018-12-31&quot;, end_date = &quot;2019-12-31&quot;, as = &quot;xts&quot;) %&gt;% Ask() USDBRL_2019_monthly &lt;- to.monthly(USDBRL_2019, indexAt = &quot;firstof&quot;) %&gt;% Cl() USDBRL_2019_monthly ## USDBRL_2019.Close ## 2018-12-01 3.8748 ## 2019-01-01 3.6519 ## 2019-02-01 3.7385 ## 2019-03-01 3.8967 ## 2019-04-01 3.9453 ## 2019-05-01 3.9407 ## 2019-06-01 3.8322 ## 2019-07-01 3.7649 ## 2019-08-01 4.1385 ## 2019-09-01 4.1644 ## 2019-10-01 4.0041 ## 2019-11-01 4.2240 ## 2019-12-01 4.0307 Note que aqui o argumento start_date = \"2018-12-31\", definimos dessa maneira para que a série de preços começe com os dados de dezembro/2018 e assim ao construirmos a série mensal para o cálculo dos retornos tenhamos o retorno de janeiro/2019. De outra forma teríamos o retorno de janeiro/2019 igual a NA. Agora, utilizando a função Return.calculate, vamos calcular os retornos simples para a série mensal de cotações do Dólar Americano. Return.calculate(USDBRL_2019_monthly, method = &quot;discrete&quot;) %&gt;% setNames(&quot;R_t&quot;) -&gt; USDBRL_2019_monthly_returns 100 * USDBRL_2019_monthly_returns ## R_t ## 2018-12-01 NA ## 2019-01-01 -5.7525550 ## 2019-02-01 2.3713683 ## 2019-03-01 4.2316437 ## 2019-04-01 1.2472092 ## 2019-05-01 -0.1165944 ## 2019-06-01 -2.7533179 ## 2019-07-01 -1.7561714 ## 2019-08-01 9.9232383 ## 2019-09-01 0.6258306 ## 2019-10-01 -3.8492940 ## 2019-11-01 5.4918708 ## 2019-12-01 -4.5762311 Visualizando os dados em um gráfico de barras. barplot(USDBRL_2019_monthly_returns * 100, las = 2, ylim = c(-5, 10)) 4.1.2 Entendendo os preços em função dos retornos Vimos com escrever os retornos em função dos preços, uma outra forma de entender os retornos simples é inverter a Eq.(4.1) e escrevê-la em termos do preço \\(P_t\\). \\[\\begin{equation} P_t = P_{t-1} (1 + R_t) = P_{t-1} + R_t P_{t-1} \\tag{4.2} \\end{equation}\\] O preço \\(P_t\\) pode ser interpretado como um choque do retorno \\(R_t\\) no preço \\(P_{t-1}\\). O retorno \\(R_t\\) está associado ao período entre os instantes \\(t\\) e \\(t-1\\), de forma análoga, \\(R_{t-1}\\) está associado aos instantes \\(t-1\\) e \\(t-2\\), e assim por diante para diferentes valores de \\(t\\). Por isso o retorno simples também é conhecido como retorno discreto, pois, para cada período entre instantes dois instantes de tempo temos um choque discreto associado a cada movimento dos preços. Note que na função Return.calculate temos o argumento method=\"discrete\". 4.1.3 Composição de retornos simples Vimos como obter a série de retornos a partir da série de preços de um ativo. Agora vamos ver como obter a série de preços a partir da série de retornos e para isso é necessário entender como compor os retornos. A composição de retornos ajuda a responder a pergunta: Dado que temos os retornos simples de dois meses consecutivos, qual é o retorno total nos dois meses? Para obter os retornos mensais partimos da série de preços diários, para obter os retornos de 2 meses podemos partir da série de preços de 2 meses, mas este período não possui uma função com to.monthly de forma que dificulta um pouco o trabalho. Contudo, podemos partir da série de retornos mensais e criar uma série de retornos bimestrais compondo os retornos mensais. Isso vale para dois meses e vale para \\(N\\) meses, podemos construir séries de retornos trimestrais, semestrais e assim por diante. Vamos começar com um exemplo estático. Da série USDBRL_2019_monthly_returns vamos pegar os retonos dos últimos 2 meses, novembro e dezembro de 2019. last(USDBRL_2019_monthly_returns * 100, 2) ## R_t ## 2019-11-01 5.491871 ## 2019-12-01 -4.576231 Em novembro/2019 tivemos um retorno de 5,49% e em dezembro/2019 um retorno negativo de -4,57%. O retorno total no período é dado pela equação \\[\\begin{equation} R_{nov-dez/19} = (1 + R_{nov/19})(1 + R_{dez/19}) - 1 \\tag{4.3} \\end{equation}\\] Dessa forma, no R, utilizamos a função prod para calcular o retorno composto para este período. Modo base R: 100 * (prod(1 + last(USDBRL_2019_monthly_returns, 2)) - 1) ## [1] 0.6643191 Modo tidyverse: last(USDBRL_2019_monthly_returns, 2) %&gt;% `+`(1) %&gt;% prod() %&gt;% `-`(1) %&gt;% `*`(100) ## [1] 0.6643191 O retorno total é de 0,66%, praticamente zero, devido a queda de dezembro. Mas de onde vem a Eq.(4.3)? Vamos demostrar. Temos os retonos \\(R_t\\) e \\(R_{t-1}\\) referentes aos meses de novembro e dezembro de 2019. Vamos começar escrevendo o preço \\(P_t\\) conforme a Eq.(4.2). \\[\\begin{equation} P_t = P_{t-1} (1 + R_t) \\end{equation}\\] Aqui temos o preço de dezembro/2019 (\\(t\\)) como função do preço de novembro/2019 (\\(t-1\\)). Vamos escrever \\(P_{t-1}\\) também segundo a Eq.(4.2) substituindo na equação acima. \\[\\begin{equation} P_t = P_{t-2} (1 + R_{t-1}) (1 + R_t) \\end{equation}\\] Agora temos o preço de dezembro/2019 (\\(t\\)) como função do preço de outubro/2019 (\\(t-2\\)) Temos também os retornos \\(R_t\\) e \\(R_{t-1}\\) compostos produzindo o retorno total no período de novembro-dezembro/2019. Para simplificar podemos escrever \\[\\begin{equation} P_t = P_{t-2} (1 + \\bar{R}_{2}) \\end{equation}\\] onde \\((1 + \\bar{R}_{2})\\) é o retorno total no período de dois meses. Generalizando para \\(N\\) meses (ou dias, ou anos) temos que o retorno total neste período é dado por: \\[\\begin{equation} (1 + \\bar{R}_{N}) = \\prod_{i=0}^{N-1} (1 + R_{t-i}) \\tag{4.4} \\end{equation}\\] Podemos calcular o retorno simples para todo o ano de 2019 utilizando a função prod. 100 * (prod(1 + na.trim(USDBRL_2019_monthly_returns)) - 1) ## [1] 4.023433 Dessa forma descobrimos que no ano de 2019 o Dólar Americano teve uma valorização de 4,02%. Foi necessário utilizar o método na.trim para remover o NA do primeiro elemento do cálculo dos produtos acumulados. As funções cumsum, cumprod, cummax e cummin não possuem o argumento na.rm que exclui os elementos com NA da operação, como acontece com as funções sum, prod, max e min. Por este motivo é importante fazer este tratamento antes de executar estas funções. No R ainda calcular o calcular a série de retornos simples compostos usando a função cumprod: 100 * (cumprod(1 + na.trim(USDBRL_2019_monthly_returns)) - 1) ## R_t ## 2019-01-01 -5.7525550 ## 2019-02-01 -3.5176009 ## 2019-03-01 0.5651905 ## 2019-04-01 1.8194487 ## 2019-05-01 1.7007329 ## 2019-06-01 -1.0994116 ## 2019-07-01 -2.8362754 ## 2019-08-01 6.8055125 ## 2019-09-01 7.4739341 ## 2019-10-01 3.3369464 ## 2019-11-01 9.0120780 ## 2019-12-01 4.0234335 Isso fica legal de ver em um gráfico de barras. barplot(100 * (cumprod(1 + na.trim(USDBRL_2019_monthly_returns)) - 1), las = 2, ylim = c(-5, 10)) É possível notar que o grande resultado para o ano do Dólar Americano ocorreu em julho/2019, após este mês ele ficou de lado mantendo esse resultado. 4.1.4 Retorno médio Outra pergunta interessante para se fazer aqui é: Tá ok, eu sei que o retorno simples para o Dólar Americano em 2019 foi de 10,37%, mas qual é o retorno mensal médio de 2019? Este seria o retorno que poderíamos comparar com outros investimentos que também apresentam retornos mensais, como a Poupança por exemplo. Sabendo que o retorno simples no período é dado pela Eq.(4.4), podemos considerar que os retornos \\(R_t\\) são constantes e iguais a \\(\\hat{R}\\). Assim teríamos, \\[\\begin{equation} \\begin{array}{lcr} (1 + \\bar{R}_{N}) &amp; = &amp; \\prod_{i=0}^{N-1} (1 + \\hat{R}) \\\\ &amp; = &amp; (1 + \\hat{R})^N \\end{array} \\end{equation}\\] Consequentemente temos \\[\\begin{equation} (1 + \\hat{R}) = (1 + \\bar{R}_{N})^{\\frac{1}{N}} \\tag{4.5} \\end{equation}\\] É uma média geométrica dos retornos simples \\[ 1 + \\hat{R} = \\left( \\prod_{i=0}^{N-1} (1 + R_{t-i}) \\right)^{\\frac{1}{N}} \\] Esta é a razão pela qual é incorreto calcular a média aritimética dos retornos simples. No R calculamos essa operação usando o operado de exponenciação ^. R_med &lt;- ( prod(1 + na.trim(USDBRL_2019_monthly_returns)) ) ^ (1/length(na.trim(USDBRL_2019_monthly_returns))) - 1 100 * R_med ## [1] 0.3292576 Obtemos 0,33% ao mês! Para efeito de comparação, vamos considerar a taxa SELIC (taxa básica de juros na economia), esta taxa é de 2,0% ao ano. Podemos calcular o seu equivalente mensal aplicando a mesma fórmula. SELIC &lt;- 0.02 SELIC_med &lt;- (1 + SELIC) ^ (1 / 12) - 1 100 * SELIC_med ## [1] 0.1651581 Temos 0,17%, aproximadamente a metade do retorno obtido com o Dólar Americano no ano de 2019. 4.2 Retornos logaritimicos Os retornos logaritimicos são dados pela diferença entre os logarítimos dos preços dos ativos. \\[\\begin{equation} r_t = \\log \\left( \\frac{P_t}{P_{t-1}} \\right) = \\log P_t - \\log P_{t-1} = p_t - p_{t-1} \\tag{4.6} \\end{equation}\\] No R fazemos como na equação acima, tiramos a diferença dos logaritimos dos preços \\(P_t\\) 100 * diff(log(USDBRL)) %&gt;% setNames(&quot;r_t&quot;) ## r_t ## 2020-09-01 NA ## 2020-09-02 0.01674839 ## 2020-09-03 -1.23948413 ## 2020-09-04 -0.43615012 Os valores são bastante próximos aos dos retornos simples. Também podemos usar a função Return.calculate do pacote PerformanceAnalytics para calcular os retornos logaritimicos, só que neste caso, passando o argumento method = \"log\". 100 * Return.calculate(USDBRL, method = &quot;log&quot;) %&gt;% setNames(&quot;r_t&quot;) ## r_t ## 2020-09-01 NA ## 2020-09-02 0.01674839 ## 2020-09-03 -1.23948413 ## 2020-09-04 -0.43615012 Como o termo retorno logaritimico é muito extenso pra escrever e falar, vamos usar com mais frequência o termo log-retorno. 4.2.1 Entendendo os preços em função dos retornos Invertendo a Eq.(4.6) para obter a equação dos preços, da mesma maneira que fizemos na Eq.(4.2), temos: \\[\\begin{equation} P_t = P_{t-1} \\exp\\left( r_t \\right) \\tag{4.7} \\end{equation}\\] 4.2.2 Composição dos log-retornos A composição dos log-retornos se dá da seguinte forma: \\[\\begin{equation} \\exp(\\bar{r}_{N}) = \\prod_{i=0}^{N-1} \\exp(r_{t-i}) = \\exp\\left(\\sum_{i=0}^{N-1} r_{t-i}\\right) \\end{equation}\\] Dessa forma temos que o log-retorno no período, \\(\\bar{r}_{N}\\), é dado pela soma dos retornos \\[\\begin{equation} \\bar{r}_{N} = \\sum_{i=0}^{N-1} r_{t-i} \\tag{4.8} \\end{equation}\\] No R podemos calcular o log-retorno no período usando a função sum. Usando a série de preços do Dólar Americano em 2019, temos: 100 * sum(Return.calculate(USDBRL_2019_monthly, method = &quot;log&quot;), na.rm = TRUE) ## [1] 3.944601 Note que aqui usamos na.rm = TRUE para indicar para a função sum que os elementos com NA deve ser excluídos da amostra. A função mean também apresenta este argumento. Note que o log-retorno referente a 2019 é 3.94%, ligeiramente menor que o obtido com o retorno simples, que foi de 4,02%. Entretanto, estas duas abordagens são equivalentes, vamos ver isso em mais detalhes na Seção4.3. Podemos ainda no R calcular a série de log-retornos compostos usando a função cumsum, da mesma forma que fizemos com os retornos simples. 100 * cumsum(na.trim(Return.calculate(USDBRL_2019_monthly, method = &quot;log&quot;))) ## USDBRL_2019.Close ## 2019-01-01 -5.9246468 ## 2019-02-01 -3.5809587 ## 2019-03-01 0.5635993 ## 2019-04-01 1.8030948 ## 2019-05-01 1.6864324 ## 2019-06-01 -1.1054998 ## 2019-07-01 -2.8772748 ## 2019-08-01 6.5839355 ## 2019-09-01 7.2078159 ## 2019-10-01 3.2824788 ## 2019-11-01 8.6288498 ## 2019-12-01 3.9446010 4.2.3 Log-retorno médio Voltando a pergunta: Tá ok, eu sei que o log-retorno para o Dólar Americano em 2019 foi de 9,87%, mas qual é o retorno mensal médio de 2019? Dado que o log-retorno para um período com múltiplos retornos é dado pela soma dos retornos, temos que o log-retorno médio é dado pela média aritimética dos log-retornos. \\[\\begin{equation} \\hat{r} = \\frac{1}{N} \\sum_{i=0}^{N-1} r_{t-i} \\tag{4.9} \\end{equation}\\] Utilizamos a função mean no R para calcular o log-retorno médio para uma série de retornos 100 * mean(Return.calculate(USDBRL_2019_monthly, method = &quot;log&quot;), na.rm = TRUE) ## [1] 0.3287167 Obtivemos 0,33%, praticamente o mesmo resultado obtido com o retorno simples, que arredondado também ficou em 0,33%. 4.3 Relação entre os retornos simples e logaritimicos Como vimos anteriormente, os retornos simples e logaritimicos, são diferentes, mesmo quando se referem ao mesmo período. Bem, vamos ver aqui que são duas formulações equivalentes, pois ambas são obtidas a partir dos mesmos preços. Como \\(P_t\\) deve ser sempre o mesmo, independente do retorno que estamos utilizando, então, usando as Eqs.(4.2) e (4.7), podemos obter a relação entre os retornos simples e logaritimicos. \\[\\begin{equation} 1 + R_t = \\exp\\left( r_t \\right) \\tag{4.10} \\end{equation}\\] 4.4 Porque formas diferentes de calcular os retornos? Bem, faz sentido trabalhar com duas formas diferentes de calcular retornos? Honestamente, não! Entretanto, os retornos simples são mais intuitivos de serem utilizados nos cálculos de retornos, por outro lado os log-retornos são mais fáceis de manipular nos cálculos, principalmente devido ao fato de que podem ser somados. Devido a simplicidade de uso dos log-retornos, a grande maioria dos estudos de alocação de ativos e risco de investimentos utiliza os log-retornos. Nas próximas seções vamos abordar os conceitos de retorno esperado e risco esperado para ativos e veremos que a utilização de log-retornos é fundamental. 4.5 Retorno esperado O retorno esperado é equivalente ao retorno médio. Há diversas outras formas de estimar o retorno esperado, desde modelos matemáticos complexos até hipóteses bem fundamentadas sobre o comportamento dos ativos. Aqui vamos considerar a análise estatística em que, dada uma amostra de retornos, o retorno médio é um bom estimador para retornos futuros. Justamente por ser o valor médio, o mais comum, o esperado para essa amostra. Na estatística, a média aritimética é estimador para a média consistente para a média de uma amostra. Por esse motivo os log-retornos são utilizado para o cálculo do retorno esperado, pois são equivalentes a média aritimética dos retornos. \\[\\begin{equation} \\hat{r} = \\frac{1}{N} \\sum_{i=0}^{N-1} r_{t-i} \\end{equation}\\] A partir daqui vamos assumir que o retorno esperado é a média aritimética dos log-retornos. 4.5.1 Retornos anualizados Outro conceito importante é o de retorno anualizado. Primeiro: porque anualizar os retornos? No mercado financeiro é muito comum se trabalhar com taxas ao ano como a SELIC e o CDI, que são taxas básicas de juros e sempre são cotadas ao ano. Dessa forma, é interessante converter os retornos para uma base anual de maneira que seja possível comparar os retornos esperados com retornos de outros investimentos. Para calcular o retorno anualizado, multiplicamos o retorno esperado pela quantidade de períodos que temos em 1 ano. Por exemplo: retorno esperado diário - multiplicamos por 252, que é uma convenção adotada no mercado brasileiro que significa 252 dias úteis por ano. retorno esperado mensal - multiplicamos por 12, pois 1 ano tem 12 meses. Vamos utilizar a nossa série USDBRL_2019 com as cotações do Dólar Americano para 2019. Primeiro vamos calcular os retornos diários USDBRL_2019_daily_returns &lt;- Return.calculate(USDBRL_2019, method = &quot;log&quot;) USDBRL_2019_daily_mean_return &lt;- mean(USDBRL_2019_daily_returns, na.rm = TRUE) 100 * USDBRL_2019_daily_mean_return ## [1] 0.01559131 Note que o retorno diário para o USDBRL em 2019 foi de 0,0156%. Vamos multiplicá-lo por 252 para encontrar o retorno anualizado 100 * USDBRL_2019_daily_mean_return * 252 ## [1] 3.92901 Obtivemos 3,93% com retorno diário anualizado, ficou bastante próximo do retorno anual calculado com a composição dos retornos mensais que ficou em 3,94%. Utilizando os retornos mensais Return.calculate(USDBRL_2019_monthly, method = &quot;log&quot;) %&gt;% setNames(&quot;R_t&quot;) -&gt; USDBRL_2019_monthly_log_returns USDBRL_2019_monthly_mean_return &lt;- mean(USDBRL_2019_monthly_log_returns, na.rm = TRUE) 100 * USDBRL_2019_monthly_mean_return ## [1] 0.3287167 Multiplicando USDBRL_2019_monthly_mean_return por 12 para anualizar o retorno temos 100 * USDBRL_2019_monthly_mean_return * 12 ## [1] 3.944601 Novamente a estimativa do retorno anualizado ficou muito próximo dos valores já encontrados, 3,94%. A anualização dos retornos é muito útil para converter os retornos entre períodos diários, mensais e anuais com contas simples que podem produzir análises interessantes para comparação de investimentos. 4.6 Risco esperado Há diversas formas de calcular o risco esperado de um ativo. Aqui vamos considerar que a volatilidade dos log-retornos será a medida de risco esperado para o ativo. Para calcular a volatilidade precisamos calcular a variância dos log-retornos, que é dada pela fórmula: \\[ \\textrm{Var}(r_t) = \\frac{1}{N-1}\\sum_{i=0}^{N-1}\\left( r_{t-i} - \\bar{r} \\right)^2 \\] A volatilidade dos retornos é dada pela raiz quadrada da variância e representada por \\(\\sigma\\). \\[ \\sigma = \\sqrt{\\textrm{Var}(r_t)} \\] A volatilidade também é conhecida como desvio padrão dos retornos, na verdade é o contrário, mas a ordem dos fatores não altera o produto. A volatilidade é um conceito amplo para descrever o comportamento da dinâmica de um ativo. Há diversas formas de estimar a volatilidade, aqui estamos assumindo a raiz quadrada da variância amostral. Contudo, a volatilidade não é observada, diferente dos preços dos ativos e das taxas de juros, logo, sua estimação é sempre calcada em um conjunto de hipóteses. Em termos gerais, o objetivo de caracterizar o risco esperado em termos da volatilidade é que a partir dessa medida possamos definir perdas esperadas associadas a probabilidades. Ou mesmo que não defina-se uma perda esperada, conhecendo a volatilidade de diferentes ativos é possível comparar os ativos por uma métrica de risco esperado potencial. No R utilizamos a função sd (de standard deviation e assim com sum e mean também possui um argumento na.rm) 100 * sd(Return.calculate(USDBRL_2019, method = &quot;log&quot;), na.rm = TRUE) ## [1] 0.6971556 O desvio padrão tem uma relação direta com os retornos, eles estão na mesma unidade. Aqui temos uma volatilidade de 0,69% para um retorno esperado de 0,0156%. Já já vamos saber como avaliar se isso é bom ou ruim, comparado a que? Por esse motivo o desvio padrão é utilizado para definir um intervalo de confiança para o retorno esperado. Por ora vamos segurar um pouco aqui, mais adiante vamos trazer uma abordagem estatística sobre os retornos e vamos falar mais sobre o desvio padrão. 4.6.1 Volatilidade anualizada Da mesma maneira que anualizamos os retornos, é necessário anualizar a volatilidade para evitar que façamos comparações de maçãs com bananas. A conta aqui é menos direta então vou colocar direto a equação. Para anualizar volatilidade diária (obtida de retornos diários) multiplicamos por raiz quadrada de 252 (quantidade de dias úteis no ano). \\[\\begin{equation} \\sigma_a = \\sigma_d\\sqrt{252} \\end{equation}\\] Para anualizar volatilidade mensal multiplicamos por raiz quadrada de 12 (número de meses no ano) \\[\\begin{equation} \\sigma_a = \\sigma_m\\sqrt{12} \\end{equation}\\] No exemplo acima, temos a volatilidade diária, logo, para anualizar a volatilidade vamos multiplicar por \\(\\sqrt{252}\\). 100 * sd(Return.calculate(USDBRL_2019, method = &quot;log&quot;), na.rm = TRUE) * sqrt(252) ## [1] 11.067 Com a volatilidade anualizada podemos escrever que o retorno anualizado é de 3,9% com uma volatilidade de 11%. Nas próximas seções vamos entender como comparar ativos com diferentes medidas de risco e retorno. 4.7 Exercícios - Análise de Retornos Obtenha as séries de preços de Petrobrás PN (PETR4.SA), Lojas Renner (LREN3.SA), Ambev (ABEV3.SA), da ETF BOVA11 (BOVA11.SA) e do Índice IBOVESPA (^BVSP), para o período de 2010-01-01 a 2020-01-01 (10 anos de dados). Use a função getSymbols passando os símbolos dados. Estas séries possuem valores faltantes NA, é necessário fazer o tratamento. Para cada uma destas séries faça: Limpeza dos dados faltantes Cálculo do log-retorno diário Cálculo do retorno esperado anualizado Cálculo da volatilidade esperada anualizada Com as séries dos exercício anterior, faça para cada uma delas: Limpeza dos dados faltantes Cálculo do log-retorno diário Dividir as séries em 5 períodos de 2 anos cada (lembre de usar a indexação dos objetos xts) e calcule as estatísticas: retorno esperado e volatilidade anualizados, para cada sub-período. O que você observa? As medidas permanecem constantes ao longo do tempo? Fazer a mesma análise para retornos diários simples - as medidas mudam substancialmente? Dica: calcule a volatilidade usando o desvio padrão dos retornos, não é exato, mas é uma boa aproximação. Obtenha as séries de preços de Banco Itaú PN (ITUB4.SA), VALE (LREN3.SA), da ETF IVVB11 (IVVB11.SA) (replica o índice S&amp;P 500), da ETF PIBB11 (PIBB11.SA) (replica o índice IBrX50), para o período de 2015-01-01 a 2020-01-01 (5 anos de dados). Use a função getSymbols passando os símbolos dados. Estas séries possuem valores faltantes NA, é necessário fazer o tratamento. Para cada uma destas séries faça: Limpeza dos dados faltantes Cálculo da série de preços mensais Cálculo do log-retorno mensal Cálculo do retorno esperado e volatilidade mensal Cálculo do retorno esperado e volatilidade anualizados Repira a análise do segundo exercício utilizando as moedas USD, EUR, CNY, GBP e CHF. Dica: as moedas podem ser obtidas com a função get_currency do pacote rbcb. Use a função list_currencies do rbcb para descobrir os paises dessas moedas. Avalie as características das moedas. "],
["análise-de-risco.html", "Capítulo 5 Análise de Risco 5.1 Visualização dos Retornos 5.2 Análise Estatística dos Retornos 5.3 Medidas de Risco 5.4 Análise em Janela Móvel 5.5 Túnel de Volatilidade 5.6 Comparando Ativos 5.7 Exercícios - Análise de Risco", " Capítulo 5 Análise de Risco Acabamos de ver como trabalhar com retornos financeiros, qual a diferença entre retornos simples e log-retornos, porque é mais comum trabalharmos com os log-retornos e como calcular o retorno esperado e a volatilidade de ativos financeiros. Dando continuidade vamos entender o que fazer com tudo isso. Como fazer a análise de risco de ativos e como comparar ativos financeiros, levando em consideração o seu retorno esperado e a sua volatilidade (análise de risco e retorno). Vamos ver que, em geral, o retorno e o risco costumam caminhar juntos de forma que para obter maiores retornos em investimentos devemos estar dispostos a assumir mais risco. Se algum investimento promete maior retorno com menos risco, tome cuidado, pode ser uma fraude! 5.1 Visualização dos Retornos No Capítulo 4 vimos como calcular os retornos a partir da série de preços de um ativo financeiro, assim como calcular o seu retorno esperado e a sua volatilidade. Mas um ponto muito importante na análise de ativos financeiro é a observação dos dados. Dessa maneira, vamos dar uma passo para trás e introduzir uma análise qualitativa dos retornos que envolve a visualização dos log-retornos. Vamos começar obtendo a série de cotação de fechamento do índice IBOVESPA no período de 10 anos de 2010 a 2019. Para obter a série do índice vamos utiliza a função getSymbols do pacote quantmod. O símbolo do IBOVESPA é ^BVSP. IBOVESPA &lt;- getSymbols(&quot;^BVSP&quot;, from = &quot;2009-12-31&quot;, to = &quot;2019-12-31&quot;, auto.assign = FALSE) Como é fundamental ver os dados com os quais se está trabalhando, vamos visualizar a série do índice, pegando a série de cotações de fechamento. IBOVESPA %&gt;% Cl() %&gt;% autoplot() O que observamos? De 2010 até 2016, aproximadamente há uma tendência de queda. A partir de 2016 há uma forte tendência de alta. Agora vamos calcular os retornos das cotações de fechamento: IBOVESPA_rets &lt;- IBOVESPA %&gt;% Cl() %&gt;% log() %&gt;% diff() Vamos visualizar os retornos agora: IBOVESPA_rets %&gt;% autoplot() O que observamos? Oscilações tanto positivas quanto negativas Sem tendência Pontos extremos Quando temos pontos extremos podemos perceber uma aglomeração nesse sentido Observando os retornos do índice temos um sobe e desce errático, sem tendência, bem diferente da série do índice que claramente apresenta tendência. Essa ausência de tendência é uma característica fundamental da série de retornos. Na próxima seção vamos introduzir a análise estatística dos retornos e como ela pode nos ajudar na caracterização dessa variável. 5.2 Análise Estatística dos Retornos Uma forma de descrever os retornos é assumir que podem ser descritos como uma variável aleatória e assim usar a teoria da probabilidade para descrever o seu comportamento. A variável IBOVESPA_rets que tem a série de retornos é uma realização dessa variável aleatória, a qual vamos chamar de amostra aleatória. A partir dessa amostra realizamos a análise estatística dos retornos, onde vamos apresentar algumas métricas úteis para descrever a variável aleatória, e muito úteis para comparar diferentes varíaveis aleatórias. Pois se consideramos os retornos do IBOVESPA uma variável aleatória, os retornos no índice S&amp;P 500, por exemplo, também podem ser descritos como uma variável aleatória só que uma diferente do IBOVESPA. A descrição matemática de uma variável aleatória não será vista aqui, não é o objetivo. Entretanto, vamos apresentar algumas avaliações qualitativas que permitam caracterizar a variável aleatória e nos suportem na avaliação de risco dos ativos. 5.2.1 Estatísticas Descritivas São medidas resumo que são calculadas para qualquer amostra aleatória. São úteis para caracterizar e entender a amostra aleatória, assim como comparar variáveis aleatórias diferentes. São exemplos de estatísticas descritivas para uma amostra aleatória: a média, a mediana, alguns quartis e valores de mínimo e máximo. No R a função summary provê algumas estatísticas descritivas da nossa série de retornos do IBOVESPA summary(coredata(IBOVESPA_rets)) ## BVSP.Close ## Min. :-0.092107 ## 1st Qu.:-0.008163 ## Median : 0.000262 ## Mean : 0.000146 ## 3rd Qu.: 0.008523 ## Max. : 0.063887 ## NA&#39;s :23 Note que estas medidas ajudam a entender como a amostra está distribuída. Conhecendo os pontos de mínimo e máximo temos o intervalo de cobertura da amostra. No caso dos retornos diários do IBOVESPA temos um mínimo de -0,092107 e um máximo de 0,063887. Com isso podemos concluir que em um intervalo de 10 anos o pior retorno diário para o IBOVESPA foi de -9% e o seu maior retorno foi de 6%. Como os retornos são calculados com base no preço de fechamento, temos que eventualmente ao longo de um dia de negociação o índice pode ter sofrido uma queda superior a 9%, contudo, para o fechamento este é o pior resultado no período. O primeiro quartil, que marca 25% dos dados da amostra, está em -0,008163 indicando que um quarto dos dados da amostra está abaixo de -0,8%, de outra forma temos que 75% dos dados está acima de -0,8%, ou seja, em 75% dos dias da amostra os retornos foram superiores a -0,8%. A mediana é ligeiramente superior a média, na verdade quase o dobro, isso pode ser uma indicação de qua amostra é negativamente assimétrica, pois a mediana é o meio da amostra e a média o seu ponto médio. Todavia, os valores aqui de média e mediana são muito próximos de zero, dessa maneira, a análise persiste, mas eventualmente esse efeito não seja significativo. Além dessas medidas de posição, há também as medidas de dispersão. Já vimos no Capítulo 4 a variância e o desvio padrão (volatilidade) var(IBOVESPA_rets %&gt;% as.numeric(), na.rm = TRUE) ## [1] 0.0001973679 sd(IBOVESPA_rets, na.rm = TRUE) ## [1] 0.01404877 Mas temos também a assimetria (skewness), que indica o quão simétrica é a amostra em torno da média. Uma assimetria zero indica que a amostra é simétrica, a assimetria positiva indica uma amostra com maior peso para valores acima da média e assimetria negativa o oposto. skewness(IBOVESPA_rets, na.rm = TRUE) ## [1] -0.1643848 Conforme falamos na análise da mediana, a amostra apresentava uma assimetria negativa, e o skewness confirma essa hipótese. Outra medida interessante é a curtose (kurtosis). A curtose é sempre positiva e quanto maior a curtose maior a probabilidade de que eventos extremos ocorram. Como balisador usamos a curtose da distribuição Normal (Gaussiana) que é uma distribuição muito importante e aparece em diversos fenômenos. Para a distribuição Normal e curtose é 3, dessa maneira, se a amostra apresenta uma curtose maior que 3 ela tem probabilidade de eventos extremos maior do que uma distribuição Normal. kurtosis(IBOVESPA_rets, na.rm = TRUE, method = &quot;moment&quot;) ## [1] 4.945592 Como vemos os retornos do IBOVESPA apresentam uma curtose maior do que 3, logo, há uma probabilidade de eventos extremos maior do que uma distribuição Normal. Isso não é necessariamente bom ou ruim, porque os eventos extremos podem ser positivos ou negativos e apesar dos retornos extremos negativos serem indesejados, os retornos extremos positivos são altamente desejáveis. Para efeito de comparação, vamos calcular as estatísticas descritivas para uma amostra aleatória Normal com média e variância dos retornos do IBOVESPA. # aprox. 10 anos x &lt;- rnorm(2500, mean = mean(IBOVESPA_rets, na.rm = TRUE), sd = sd(IBOVESPA_rets, na.rm = TRUE)) c( summary(x), skewness = skewness(x), kurtosis = kurtosis(x, method = &quot;moment&quot;) ) ## Min. 1st Qu. Median Mean 3rd Qu. ## -5.066773e-02 -9.781212e-03 -3.176260e-04 7.215541e-05 9.822638e-03 ## Max. skewness kurtosis ## 4.412253e-02 2.768001e-02 2.919392e+00 Note que na amostra Normal os pontos de mínimo e máximo são bem menores que na distribuição de retornos do IBOVESPA, esse é um efeito que pode ser explicado, pela curtose mais elevada da distribuição de retornos. 5.2.2 Histograma Um histograma é um gráfico que representa a distribuição construida a partir da amostra aleatória, é um gráfico da distribuição amostral. No PerformanceAnalytics temos a função chart.Histogram. IBOVESPA_rets %&gt;% chart.Histogram(breaks = 50, main = &quot;Histograma de retornos do IBOVESPA&quot;, show.outliers = TRUE, methods = &quot;add.normal&quot;, lwd = 1) O que observamos? Pico em torno de zero, região mais provável ou de maior frequência. Pontos distantes do zero, positivos e negativos, indicando a ocorrência de eventos extremos No geral, tipicamente simétrico, se ignorarmos os extremos. A análise estatística dos retornos é fundamental pra entendermos a amostra e fazer qualquer tratamento nos dados para corrigir distorções que eventualmente surjam nos dados. É fundamental visualizar os dados, calcular as estatísticas descritivas e as estatísticas de dispersão e visualizar o histograma dos retornos, se comparar com a distribuição Normal, melhor ainda. Esse processo contribui para aumentar a sensibilidade com os dados e o senso crítico ao inicial uma análise. 5.3 Medidas de Risco Vamos introduzir aqui algumas medidas de risco e utilizar alguns exemplos com o ativo BOVA11, que é um ETF (fundo negociado em bolsa) que reproduz o retorno do índice IBOVESPA. O BOVA11 não é exatamente, na vírgula, o índice IBOVESPA, mas é muito próximo do índice. Vamos criar as séries de preços do BOVA11, de retornos diários, de preços mensais e retornos mensais. BOVA11 &lt;- getSymbols(&quot;BOVA11.SA&quot;, to = &quot;2019-12-31&quot;, auto.assign = FALSE) BOVA11_rets &lt;- BOVA11 %&gt;% Cl() %&gt;% log() %&gt;% diff() BOVA11_monthly &lt;- BOVA11 %&gt;% Ad() %&gt;% to.period() BOVA11_monthly_rets &lt;- BOVA11_monthly %&gt;% Cl() %&gt;% log() %&gt;% diff() Vamos considerar um cenário onde eu tenho uma carteira com 1000 ações do BOVA11. A série de BOVA11 termina em dez/2019, e a cotação de fechamento é R$ 111,23, logo o patrimônio da carteira é R$ 111.230,00. BOVA11 %&gt;% last() %&gt;% Cl() ## BOVA11.SA.Close ## 2019-12-30 111.23 Dessa forma e para começarmos a discutir sobre as medidas de risco vou colocar algumas perguntas que precisam ser respondidas. Quanto eu (investidor) posso perder, em valor, para uma oscilação extrema do BOVA11 considerando o período de 1 mês? Qual a probabilidade de que eu sofra uma perda de mais de 5% em 1 mês? Qual a pior perda que eu posso sofrer no meu patrimônio? Essas são perguntas objetivas que passam pela cabeça de todos os investidores e na tentativa de respondê-las nós vamos abordar as medidas de risco que nos permitem quantificar os pontos levantados. 5.3.1 Value at Risk O Value at Risk (Valor em Risco - tradução livre) ajuda a responder a pergunta: Quanto eu (investidor) posso perder, em valor, para uma oscilação extrema do BOVA11 no período de 1 mês e sabendo que o valor do ativo é R$ 111.23? Para o horizonte de investimento de 1 mês, quanto pode ser uma oscilação extrema? É necessário definir o que vem a ser uma variação extrema neste horizonte de investimento Para isso vamos usar a série de retornos de 1 mês do BOVA11, pois é necessário que os retornos estejam ajustados ao horizonte de investimento definido, e vamos observar o seu histograma. BOVA11_monthly_rets %&gt;% chart.Histogram(breaks = 30, main = &quot;Histograma de retornos do IBOVESPA&quot;, show.outliers = TRUE, methods = &quot;add.normal&quot;, lwd = 1) O que observamos: os maiores retornos positivos ocorrem acima de 15% os maiores retornos negativos ocorrem abaixo de 10% o histograma para os dados mensais não se aproxima da distribuição Normal e há alguns buracos no histograma, isso se deve ao fato da amostra ter poucos dados - note que definimos breaks = 30 Observando o histograma vemos que as perdas extremas, abaixo de 10%, ocorrem com uma frequência muito baixa, pois estão na cauda da distribução. Sabendo que o desvio padrão de BOVA11_monthly_rets é aproximadamente 5%, temos que as maiores perdas estão abaixo de 2 desvios padrão. Isso é muito ou pouco? Para nos ajudar nessa análise vamos olhar a distribuição Normal na figura abaixo: Fonte: http://www.portalaction.com.br/probabilidades/62-distribuicao-normal Com 2 desvios padrão da média (centro da distribuição) temos, aproximadamente, 5% de probabilidade para as duas caudas, como a cauda negativa é a que nos interessa, temos 2,5% de probabilidade para perdas que estão abaixo de 2 desvios padrão. Conclusão: A probabilidade de perdas maiores que 2 desvios padrão é de 2,5%, quando utilizamos a distribuição Normal como proxy. Note que estamos fazendo uma aproximação considerando a distribuição Normal para chegarmos a essa probabilidade. Agora a pergunta é: dado que eu sei que a probabilidade de termos uma perda maior que 2 desvios padrão é de 2,5%, como calcular essa perda em financeiro? Para isso vamos usar a função qnorm que dada uma probabilidade ela retorna o valor associado, considerando uma distribuição Normal. Dado que temos a média e o desvio padrão dos retornos mensais, vamos plugar estes parâmetros na distribuição Normal para obter a perda associada a probabilidade de 2,5%. mu &lt;- BOVA11_monthly_rets %&gt;% na.omit() %&gt;% mean() sigma &lt;- BOVA11_monthly_rets %&gt;% na.omit() %&gt;% sd() qnorm(0.025, mean = mu, sd = sigma) ## [1] -0.1015289 Para essa amostra de retornos temos que a probabilidade de uma perda maior do que 10,15% é de 2,5%. De posse do retorno podemos aplicar a Eq.(4.7) para calcular a variação no preço para este retorno. Sabemos que último preço de BOVA11 é R$ 111,23, dessa forma a perda é dada por: r_t &lt;- qnorm(0.025, mean = mu, sd = sigma) P_t &lt;- 111.23 1000 * P_t * (1 - exp(r_t)) ## [1] 10738.7 Temos que para o horizonte de investimentos de 1 mês, a carteira com 1000 posições de BOVA11 tem um Value at Risk de R$ 10.738,70 com nível de confiança de 95%. Essa é a forma que se constuma ler o Value at Risk. 5.3.2 Drawdown Dado o histórico do BOVA11, qual a pior perda que eu posso sofrer no meu patrimônio? quanto tempo eu vou ficar amargando essa miséria? Na tentativa de responder essa pergunta usamos o drawdown. O drawdown é uma perda acumulada em uma sequência de perdas. Como se dá isso? As séries de retornos são bastante simétricas em torno de uma média, que é bem próxima de zero. Dessa maneira, podemos supor que em geral os retornos sobem e descem com a mesma probabilidade. Entretanto, existem períodos que ocorrem sequências de quedas e é isso que o drawdown mede, dada uma sequência de quedas: Quando ela começa? Quando termina ? Qual a magnetude da perda? No pacote PerformanceAnalytics tem algumas funções para trabalhar com drawdown. Vejamos o gráfico do drawdown para os retornos diários do BOVA11 no ano de 2019. chart.Drawdown(BOVA11_rets[&quot;2019&quot;]) Note que no gráfico as perdas começam, há uma recuperação, mas não suficiente para reverter o estado de perda. Quando puxamos os dados de drawdowns para o ano de 2019 (usando a função table.Drawdowns do PerformanceAnalytics) temos: table.Drawdowns(BOVA11_rets[&quot;2019&quot;]) ## From Trough To Depth Length To Trough Recovery ## 1 2019-03-19 2019-05-16 2019-06-21 -0.1057 66 41 25 ## 2 2019-07-11 2019-08-26 2019-10-22 -0.0937 74 33 41 ## 3 2019-02-05 2019-02-11 2019-03-13 -0.0433 23 5 18 ## 4 2019-11-08 2019-11-19 2019-12-04 -0.0322 17 7 10 ## 5 2019-01-28 2019-01-28 2019-02-01 -0.0224 5 1 4 Note que o maior drawdown gera uma perda de 10,57%, com uma duração de 66 dias, do começo até zerar a perda, a pior ponto acontece em 41 dias e após este ponto são 25 dias de recuperação. 5.3.3 Short-Fall Risk Vimos como quantificar a perda dado um nível de risco associado a uma probabilidade no cálculo do VaR, agora vamos inverter a análise, e vamos calcular a probabilidade de ter uma perda maior que um determinado valor. Ou seja, como calcular a probabilidade de um retorno cair abaixo de 5%? 100 * sum(BOVA11_rets &lt; -0.05, na.rm = TRUE) / length(BOVA11_rets) ## [1] 0.1603421 Para os retornos diários temos uma probabilidade de 0,16% de termos retornos menores que 5%. 100 * sum(BOVA11_monthly_rets &lt; -0.05, na.rm = TRUE) / length(BOVA11_monthly_rets) ## [1] 12.08791 Os retornos mensais apresentam uma probabilidade de 12,09% de probabilidade para retornos menores que 5%. 5.4 Análise em Janela Móvel Análise em janela móvel é útil para a avaliação da dinâmica temporal dos dados. Por exemplo, temos a série de retornos do IBOVESPA de 2010 a 2019 e podemos calcular a média e o desvio padrão para essa amostra. c( mean = IBOVESPA_rets %&gt;% na.omit %&gt;% mean(), sd = IBOVESPA_rets %&gt;% na.omit %&gt;% sd() ) ## mean sd ## 0.0001459989 0.0140487672 Uma pergunta que podemos fazer é, como se comporta a média e o desvio em uma janela móvel de 21 dias (tipicamente 1 mês em dias úteis). Vamos usar a função rollmean onde passamos a série e o tamanho da janela e ela retorna uma série com as médias para as janelas contíguas de 21 dias. rollmean(IBOVESPA_rets, 21) %&gt;% autoplot() + geom_hline(yintercept = IBOVESPA_rets %&gt;% na.omit %&gt;% mean(), colour = &#39;red&#39;) Marcando em vermelho a média da amostra completa, é interessante ver que há uma grande dispersão em torno desse valor e não há tendência clara de longo prazo, o que faz sentido (porque?). A mesma análise pode ser realizada com o desvio padrão. Neste caso usamos a função rollapply que recebe a série de retornos, o tamanho da janela e a função a ser aplicada a cada janela, aqui usaremos a função sd para cálculo do desvio padrão. rollapply(IBOVESPA_rets, 21, sd) %&gt;% autoplot() + geom_hline(yintercept = IBOVESPA_rets %&gt;% na.omit %&gt;% sd(), colour = &#39;red&#39;) Curioso ver que em 2011 e 2014/2015 tivemos picos mais pronunciados no desvio padrão, indicando momentos de maior volatilidade. 5.5 Túnel de Volatilidade Complementando a análise em janela móvel para os retornos, podemos também construir um túnel de volatilidade (ou envelope de volatilidade) que é útil para uma análise qualitativa dos retornos em conjunto com o desvio padrão em janela móvel. No gráfico abaixo fazemos o gráfico dos retornos com o túnel de volatilidade e fica bem evidente que nos períodos de 2011 e 2014/2015 tivemos umas aglomerações de retornos, indicando um período de crise onde retornos mais extremos, bastante distantes da média, podem ocorrer. plot(index(IBOVESPA_rets), coredata(IBOVESPA_rets), type = &quot;l&quot;, ylim = c(-0.1, 0.1), cex.axis = .7, lwd = 1, xlab = &quot;Date&quot;, ylab = &quot;Retorno&quot;, main = &quot;Retorno diário do IBOVESPA com intervalo de confiança de 2 desvios&quot;) volatility &lt;- rollapply(IBOVESPA_rets, 21, sd) lines(index(volatility), coredata(volatility) * 2, col = &quot;red&quot;) lines(index(volatility), -coredata(volatility) * 2, col = &quot;red&quot;) 5.6 Comparando Ativos Até aqui realizamos a análise de risco para apenas um ativo. Agora vamos utilizar esta análise univariada e vamos aplicar a diversos ativos para entender como diferentes ativos podem ser comparados entre si. Vamos utilizar uma série gráficos aqui que permitem uma análise conjunta dos ativos de forma que façamos uma análise de risco comparando os ativos entre si. 5.6.1 Comparação de risco e retorno de diversos ativos: gráfico de risco x retorno Vamos começar o gráfico risco x retorno, onde no eixo x é o risco e no y os retornos. Os passos são baixar as séries de preços dos ativos com o quantmod juntar as séries de diferentes ativos em um único objeto xts criar as séries mensais e calcular os retornos calcular médias e desvios padrão para cada um dos ativos montar o gráfico risco x retorno 5.6.1.1 Baixando as séries de preços As séries dos ativos contidas em symbols são baixadas e depois juntadas com a chamada reduce(merge). Essa é uma passagem tricky que vale a pena ser executada passo a passo para que seja bem compreendida. symbols &lt;- c(&quot;BOVA11.SA&quot;, &quot;SMAL11.SA&quot;, &quot;SPXI11.SA&quot;, &quot;PETR4.SA&quot;, &quot;VALE3.SA&quot;, &quot;B3SA3.SA&quot;, &quot;ABEV3.SA&quot;, &quot;ITUB4.SA&quot;, &quot;VVAR3.SA&quot;) prices &lt;- getSymbols(symbols, from = &quot;2016-01-01&quot;, to = &quot;2019-12-31&quot;, auto.assign = TRUE) %&gt;% map(~Ad(get(.))) %&gt;% reduce(merge) %&gt;% `colnames&lt;-`(symbols) Obtidas as séries vamos ver o que temos em mãos. plot(prices, legend.loc = &quot;topleft&quot;) Nada demais, séries diferentes com diferentes ordens de grandeza, o que prejudica a avaliação. 5.6.1.2 Calculando dados mensais Usando a função to.monthly para obter as séries de preços mensais. prices_monthly &lt;- to.monthly(prices, indexAt = &quot;lastof&quot;, OHLC = FALSE) head(prices_monthly) ## BOVA11.SA SMAL11.SA SPXI11.SA PETR4.SA VALE3.SA B3SA3.SA ABEV3.SA ## 2016-01-31 39.19 37.71 78.32 4.490080 8.315054 8.961099 16.52255 ## 2016-02-29 41.45 39.65 79.03 4.768392 10.102961 10.148924 15.72897 ## 2016-03-31 48.64 44.25 75.37 7.709209 12.960191 13.406712 16.76330 ## 2016-04-30 52.15 46.65 72.21 9.490397 16.843971 15.005033 17.28939 ## 2016-05-31 47.02 44.26 76.83 7.458729 12.164614 13.986295 17.03972 ## 2016-06-30 49.90 48.45 68.58 8.738958 13.918304 15.813653 16.98622 ## ITUB4.SA VVAR3.SA ## 2016-01-31 12.00738 1.232770 ## 2016-02-29 12.23606 2.236881 ## 2016-03-31 15.04968 2.405890 ## 2016-04-30 15.86267 2.953283 ## 2016-05-31 14.02979 2.585365 ## 2016-06-30 14.64589 3.082551 Obtidas as séries de preços mensais vamos seguir com o cálculo dos retornos usando a já conhecida Return.calculate. prices_monthly_rets &lt;- Return.calculate(prices_monthly, &quot;log&quot;) head(prices_monthly_rets) ## BOVA11.SA SMAL11.SA SPXI11.SA PETR4.SA VALE3.SA ## 2016-01-31 NA NA NA NA NA ## 2016-02-29 0.05606632 0.05016571 0.009024516 0.06013862 0.1947609 ## 2016-03-31 0.15995831 0.10976437 -0.047418157 0.48040645 0.2490539 ## 2016-04-30 0.06967800 0.05281760 -0.042830831 0.20786486 0.2621104 ## 2016-05-31 -0.10355118 -0.05259168 0.062016688 -0.24089542 -0.3254615 ## 2016-06-30 0.05944800 0.09045107 -0.113594239 0.15840594 0.1346736 ## B3SA3.SA ABEV3.SA ITUB4.SA VVAR3.SA ## 2016-01-31 NA NA NA NA ## 2016-02-29 0.12447481 -0.049222058 0.01886628 0.59581881 ## 2016-03-31 0.27838779 0.063687794 0.20696912 0.07283741 ## 2016-04-30 0.11263020 0.030900753 0.05261202 0.20499754 ## 2016-05-31 -0.07030776 -0.014545521 -0.12278562 -0.13305074 ## 2016-06-30 0.12279576 -0.003144956 0.04297710 0.17589080 5.6.1.3 Calculando média e desvio padrão Tendo um objeto com todos os retornos mensais vamos calcular a média para cada ativo com colMeans que calcula a média de cada coluna de uma matriz (em nosso caso um objeto xts). exp_returns &lt;- colMeans(prices_monthly_rets, na.rm = TRUE) exp_returns ## BOVA11.SA SMAL11.SA SPXI11.SA PETR4.SA VALE3.SA B3SA3.SA ## 0.022195289 0.027360844 0.011658452 0.040536915 0.038657794 0.032656128 ## ABEV3.SA ITUB4.SA VVAR3.SA ## 0.002599821 0.023515049 0.046892935 O cálculo do desvio padrão utiliza a função StdDev do pacote PerformanceAnalytics. exp_risk &lt;- StdDev(prices_monthly_rets) exp_risk ## BOVA11.SA SMAL11.SA SPXI11.SA PETR4.SA VALE3.SA B3SA3.SA ## StdDev 0.05495577 0.05394365 0.05235481 0.1269872 0.113819 0.08488673 ## ABEV3.SA ITUB4.SA VVAR3.SA ## StdDev 0.06119064 0.07817455 0.1760825 Com isso fechamos os indicadores de risco e retorno para cada um dos ativos. 5.6.1.4 Construindo o gráfico risco x retorno A parte mais fácil é construir os gráficos e utilizar os nomes dos ativos para identificá-los facilmente no gráfico. plot(exp_risk, exp_returns, xlim = c(0.05, 0.2), ylim = c(0.0, 0.05), pch = 16) text(x = exp_risk, y = exp_returns, labels = colnames(exp_risk), pos=4) Interessante aqui é ver uma small cap (ação de empresa com menor tamanho de mercado), VVAR3, dispontando com a maior risco e retorno, seguida de PETR4 e VALE3, duas consagradas blueships. Outra coisa curiosa, o SMALL11 (ETF de small caps) com um risco ligeiramente menor que BOVA11 e com maior retorno. 5.6.2 Gráfico boxplot com retorno dos ativos O boxplot é uma forma de visualizar a dispersão dos dados e permite ainda a avaliação de pontos extremos na amostra, os outliers. Dado que possuimos uma amostra de retornos para cada ativo, podemos calcular um boxplot para cada ativo. Colocando tudo no mesmo gráfico nos permite comparar como os retornos dos ativos estão distribuidos. prices_monthly_rets %&gt;% data.frame(Date = index(.)) %&gt;% remove_rownames() %&gt;% gather(Symbol, Returns, -Date) %&gt;% ggplot(aes(x = Symbol, y = Returns)) + geom_boxplot() 5.6.3 Gráfico violinplot com as distribuições de retornos dos ativos O violinplot é muito semelhante ao boxplot. É um pouco mais fancy apesar de não deixar clara a existência de outliers, mas impressiona em um ppt. Brincadeiras a parte ele apresenta uma distribuição continua para cada ativo, o que permite identificar a simetria das distribuições dos retornos. prices_monthly_rets %&gt;% data.frame(Date = index(.)) %&gt;% remove_rownames() %&gt;% gather(Symbol, Returns, -Date) %&gt;% ggplot(aes(x = Symbol, y = Returns)) + geom_violin(fill = &quot;blue&quot;) 5.6.4 Correlação entre séries de retornos Concluindo a parte multivariada precisamos calcular a correlação entre os ativos, não poderia ficar de fora. A matriz de correlação é obtida com a função cor que retorna uma matrix quadrada com as correlações entre cada um dos pares de ativos e 1 na diagonal principal, como é uma matriz de correlação. cor(prices_monthly_rets %&gt;% na.omit()) ## BOVA11.SA SMAL11.SA SPXI11.SA PETR4.SA VALE3.SA B3SA3.SA ## BOVA11.SA 1.0000000 0.8719722 -0.47764813 0.8684556 0.4678069 0.7619350 ## SMAL11.SA 0.8719722 1.0000000 -0.51911630 0.6452371 0.3061980 0.6321611 ## SPXI11.SA -0.4776481 -0.5191163 1.00000000 -0.4666173 -0.1148997 -0.4768917 ## PETR4.SA 0.8684556 0.6452371 -0.46661726 1.0000000 0.4813710 0.6735395 ## VALE3.SA 0.4678069 0.3061980 -0.11489970 0.4813710 1.0000000 0.2238908 ## B3SA3.SA 0.7619350 0.6321611 -0.47689171 0.6735395 0.2238908 1.0000000 ## ABEV3.SA 0.4264350 0.4600609 -0.01728933 0.2039109 -0.0182789 0.3576270 ## ITUB4.SA 0.9113159 0.7489049 -0.47870662 0.7764730 0.3262517 0.6980960 ## VVAR3.SA 0.5137772 0.5543491 -0.32382206 0.2988384 0.2077724 0.4305646 ## ABEV3.SA ITUB4.SA VVAR3.SA ## BOVA11.SA 0.42643495 0.9113159 0.5137772 ## SMAL11.SA 0.46006094 0.7489049 0.5543491 ## SPXI11.SA -0.01728933 -0.4787066 -0.3238221 ## PETR4.SA 0.20391093 0.7764730 0.2988384 ## VALE3.SA -0.01827890 0.3262517 0.2077724 ## B3SA3.SA 0.35762698 0.6980960 0.4305646 ## ABEV3.SA 1.00000000 0.3439020 0.3857068 ## ITUB4.SA 0.34390196 1.0000000 0.3900220 ## VVAR3.SA 0.38570681 0.3900220 1.0000000 A matriz de covariância é calculada com a função cov. cov(prices_monthly_rets %&gt;% na.omit()) ## BOVA11.SA SMAL11.SA SPXI11.SA PETR4.SA VALE3.SA ## BOVA11.SA 0.003020137 0.002584975 -1.374289e-03 0.006060672 0.0029261381 ## SMAL11.SA 0.002584975 0.002909918 -1.466093e-03 0.004419971 0.0018799989 ## SPXI11.SA -0.001374289 -0.001466093 2.741026e-03 -0.003102253 -0.0006846843 ## PETR4.SA 0.006060672 0.004419971 -3.102253e-03 0.016125738 0.0069575226 ## VALE3.SA 0.002926138 0.001879999 -6.846843e-04 0.006957523 0.0129547701 ## B3SA3.SA 0.003554439 0.002894729 -2.119416e-03 0.007260435 0.0021631714 ## ABEV3.SA 0.001434007 0.001518591 -5.538853e-05 0.001584475 -0.0001273063 ## ITUB4.SA 0.003915143 0.003158148 -1.959257e-03 0.007708175 0.0029029070 ## VVAR3.SA 0.004971693 0.005265503 -2.985239e-03 0.006682091 0.0041640788 ## B3SA3.SA ABEV3.SA ITUB4.SA VVAR3.SA ## BOVA11.SA 0.003554439 1.434007e-03 0.003915143 0.004971693 ## SMAL11.SA 0.002894729 1.518591e-03 0.003158148 0.005265503 ## SPXI11.SA -0.002119416 -5.538853e-05 -0.001959257 -0.002985239 ## PETR4.SA 0.007260435 1.584475e-03 0.007708175 0.006682091 ## VALE3.SA 0.002163171 -1.273063e-04 0.002902907 0.004164079 ## B3SA3.SA 0.007205756 1.857612e-03 0.004632552 0.006435678 ## ABEV3.SA 0.001857612 3.744295e-03 0.001645073 0.004155837 ## ITUB4.SA 0.004632552 1.645073e-03 0.006111261 0.005368719 ## VVAR3.SA 0.006435678 4.155837e-03 0.005368719 0.031005042 A função chart.Correlation do PerformanceAnalytics traz um gráfico bem interessante e completo da correlação entre os ativos. chart.Correlation(prices_monthly_rets) Onde além dos valores de correlação também traz os níveis de significância de cada estivativa. Note que ABEV3 e VALE3 apresentam uma correlação muito baixa entre si, o que veremos no próximo capítulo, é uma boa característica quando falamos em diversificação. 5.7 Exercícios - Análise de Risco Escolher 1 série de preços de ações, ETFs ou Índices, calcular: Retornos diários logaritmicos Volatilidade em janela móvel Gráfico de túnel de volatilidade Para a série de retornos diários logaritmicos Fazer o gráfico do histograma Com a média e variância da amostra fazer o gráfico da densidade de probabilidade da distribuição normal. Comparar os gráficos. O histograma da amostra parece com uma distribuição normal? "],
["análise-de-carteiras.html", "Capítulo 6 Análise de Carteiras 6.1 Carteira de ativos 6.2 Carteira com 2 ativos 6.3 Montando uma carteira 6.4 Rebalanceamento da carteira", " Capítulo 6 Análise de Carteiras Até agora em nossa jornada já vimos como calcular retornos financeiros, como fazer sua análise estatística e sua análise de risco, onde pudemos analisar diversos ativos e comparar levando em consideração o risco e retorno de cada um. Todos estes tópicos nos trazem a análise de carteira de ativos, onde analisamos o comportamento conjunto dos ativos e descobrimos como podemos utilizá-los conjuntamente para montar uma carteira com um risco menor do que se considerarmos o investimento nos ativos separadamente. Neste capítulo é necessário um pouco de teoria, mas garanto que já entramos nos códigos para entender como tudo isso se aplica. 6.1 Carteira de ativos Vamos considerar um exemplo simples onde temos um capital \\(W\\) para ser investido em dois ativos \\(P_1\\) e \\(P_2\\). Dessa maneira, investindo 100% do capital temos \\[\\begin{equation} n_1 P_1 + n_2 P_2 = W \\tag{6.1} \\end{equation}\\] que representa a carteira de ativos onde compramos \\(n_1\\) quantidades do ativo \\(P_1\\) e \\(n_2\\) quantidades de \\(P_2\\). No ato da compra o valor da carteira é \\(W\\), ignorando custos de transação e portanto, a fração \\(\\frac{n_1 P_1}{W}\\) é o percentual da carteira alocado no ativo \\(P_1\\) e \\(\\frac{n_2 P_2}{W}\\) é o percentual referente a \\(P_2\\). Podemos demostrar dividindo ambos os lados da Eq.(6.1) pelo capital \\(W\\). Logo temos: \\[\\begin{equation} \\begin{array}{rcl} \\frac{n_1 P_1 + n_2 P_2}{W} &amp; = &amp; \\frac{W}{W} \\\\ \\frac{n_1 P_1}{W} + \\frac{n_2 P_2}{W} &amp; = &amp; 1 \\\\ w_1 + w_2 &amp; = &amp; 1 \\\\ \\end{array} \\end{equation}\\] \\(w_1 = \\frac{n_1 P_1}{W}\\) e \\(w_2 = \\frac{n_2 P_2}{W}\\) representam os pesos dos ativos \\(P_1\\) e \\(P_2\\) na carteira. 6.1.1 Variação do valor da carteira em função dos retornos dos ativos Os ativos \\(P_1\\) e \\(P_2\\) variam com o tempo, podendo ter variações positivas e negativas. Vamos escrever a variação da carteira \\(W\\) em termo das varições dos ativos que constituem a carteira. \\[ dW = \\frac{\\partial W}{\\partial P1} dP_1 + \\frac{\\partial W}{\\partial P2} dP_2 \\] onde \\(\\frac{\\partial W}{\\partial P1}\\) e \\(\\frac{\\partial W}{\\partial P2}\\) são das variações da carteira em função da variação de cada ativo (do cálculo diferencial são as derivadas parciais da carteira \\(W \\equiv W(P_1, P_2)\\)). De acordo com a Eq.(6.1) temos: \\[\\begin{equation} \\begin{array}{rcl} \\frac{\\partial W}{\\partial P1} &amp; = &amp; n_1 \\\\ \\frac{\\partial W}{\\partial P2} &amp; = &amp; n_2 \\\\ \\end{array} \\end{equation}\\] Assim \\[\\begin{equation} \\begin{array}{rcl} dW &amp; = &amp; \\frac{\\partial W}{\\partial P1} dP_1 + \\frac{\\partial W}{\\partial P2} dP_2 \\\\ &amp; = &amp; n_1 dP_1 + n_2 dP_2 \\\\ &amp; = &amp; n_1 \\frac{P_1}{P_1} dP_1 + n_2 \\frac{P_2}{P_2} dP_2 \\\\ &amp; = &amp; n_1 P_1 \\frac{dP_1}{P_1} + n_2 P_2 \\frac{dP_2}{P_2} \\\\ &amp; = &amp; w_1 W \\frac{dP_1}{P_1} + w_2 W \\frac{dP_2}{P_2} \\\\ \\end{array} \\end{equation}\\] Dividindo os 2 lados da equação por \\(W\\) para obter as relações \\(\\frac{dx}{x} \\equiv d\\log x\\). \\[\\begin{equation} \\begin{array}{rcl} \\frac{dW}{W} &amp; = &amp; w_1 \\frac{dP_1}{P_1} + w_2 \\frac{dP_2}{P_2} \\\\ d\\log W &amp; = &amp; w_1 d\\log P_1 + w_2 d\\log P_2 \\\\ \\end{array} \\end{equation}\\] O termo \\(d\\log x\\) pode ser expandido para \\(\\log x_t - \\log x_{t-1}\\) que é a definição de log-retorno. Dessa maneira podemos escrever \\(d\\log W \\equiv r_W\\), \\(d\\log P_1 \\equiv r_1\\) e \\(d\\log P_2 \\equiv r_2\\), logo: \\[ r_W = w_1 r_1 + w_2 r_2 \\] Temos então que o log-retorno da carteira é dado pela soma dos retornos ponderados pelos pesos dos ativos na carteira. 6.2 Carteira com 2 ativos Seja uma carteira com 2 ativos, o retorno dessa carteira é dado pela soma dos retornos dos ativos multiplicados pelos seus respectivos pesos na carteira. \\[ r_{c,t} = w_1 r_{1,t} + w_2 r_{2,t} \\] onde os pesos \\(w_1\\) e \\(w_2\\) são restritos a: \\(w_1 + w_2 = 1\\): 100% da carteira está alocada nestes 2 ativos \\(w_1 \\ge 0\\) e \\(w_2 \\ge 0\\): vamos adimitir apenas posições compradas na carteira Da primeira restrição temos que \\[ w_2 = 1 - w_1 \\] logo, se fizermos \\(w_1 = \\alpha\\) temos \\[ \\begin{array}{rcl} w_1 &amp; = &amp; \\alpha \\\\ w_2 &amp; = &amp; 1 - \\alpha \\end{array} \\] Consequentemente, \\[ r_{c,t} = \\alpha r_{1,t} + (1 - \\alpha) r_{2,t} \\] 6.2.1 Retorno esperado da carteira \\[ \\bar{r}_{c} = \\alpha \\bar{r}_{1} + (1 - \\alpha) \\bar{r}_{2} \\] 6.2.2 Risco esperado da carteira A variância da carteira é dada por \\[ \\sigma^2_{c} = \\alpha^2 \\sigma^2_1 + (1-\\alpha)^2\\sigma^2_2+ 2 \\alpha (1 - \\alpha) \\sigma_1 \\sigma_2 \\rho_{12} \\] onde \\(\\sigma_1\\) e \\(\\sigma_2\\) são os desvios padrão dos ativos que compõem a carteira \\(\\rho_{12}\\) é a correlação entre os retornos \\(r_{1,t}\\) e \\(r_{2,t}\\) O risco da carteira é a raiz quadrada da variância da carteira \\(\\sigma_c = \\sqrt{\\sigma^2_c}\\). Note que as equações para \\(\\bar{r}_{c}\\) e \\(\\sigma_c\\) são função apenas de \\(\\alpha\\), uma vez que escolhidos os ativos, as variáveis \\(\\bar{r}_1\\), \\(\\bar{r}_2\\), \\(\\sigma_1\\), \\(\\sigma_2\\) e \\(\\rho_{12}\\) são obtidas dos próprios ativos. Dessa maneira, podemos simular o risco e retorno esperados da carteira para todos os valores de \\(\\alpha\\) no intervalo \\([0,1]\\). symbols &lt;- c(&quot;BOVA11.SA&quot;, &quot;SPXI11.SA&quot;) prices &lt;- getSymbols(symbols, from = &quot;2016-01-01&quot;, to = &quot;2019-12-31&quot;, auto.assign = TRUE) %&gt;% map(~Ad(get(.))) %&gt;% reduce(merge) %&gt;% `colnames&lt;-`(symbols) rets &lt;- log(prices) %&gt;% diff() %&gt;% na.omit() r_i &lt;- colMeans(rets) sigma_i &lt;- apply(rets, 2, sd) rho_ij &lt;- cor(rets[,1], rets[,2]) %&gt;% as.numeric() r_c &lt;- function(alpha, R) alpha*R[1] + (1 - alpha)*R[2] sigma_c &lt;- function(alpha, SIGMA, RHO) { r &lt;- alpha * alpha * SIGMA[1] * SIGMA[1] + (1 - alpha) * (1 - alpha) * SIGMA[2] * SIGMA[2] + 2 * alpha * (1 - alpha) * SIGMA[1] * SIGMA[2] * RHO sqrt(r) } alpha &lt;- seq(0, 1, 0.01) risk &lt;- sigma_c(alpha, sigma_i, rho_ij) return_ &lt;- r_c(alpha, r_i) plot(risk, return_, type = &quot;l&quot;, xlim = c(0.0, 0.014)) alpha &lt;- seq(0, 1, 0.01) risk &lt;- sigma_c(alpha, sigma_i, 1) return_ &lt;- r_c(alpha, r_i) plot(risk, return_, type = &quot;l&quot;, xlim = c(0.0, 0.014)) alpha &lt;- seq(0, 1, 0.01) risk &lt;- sigma_c(alpha, sigma_i, -1) return_ &lt;- r_c(alpha, r_i) plot(risk, return_, type = &quot;l&quot;, xlim = c(0.0, 0.014)) alpha &lt;- seq(0, 1, 0.01) risk &lt;- sigma_c(alpha, sigma_i, rho_ij) return_ &lt;- r_c(alpha, r_i) plot(risk, return_, type = &quot;l&quot;, xlim = c(0.0, 0.014)) risk &lt;- sigma_c(alpha, sigma_i, 1) return_ &lt;- r_c(alpha, r_i) lines(risk, return_, type = &quot;l&quot;, xlim = c(0.0, 0.014), col = &quot;blue&quot;) risk &lt;- sigma_c(alpha, sigma_i, -1) return_ &lt;- r_c(alpha, r_i) lines(risk, return_, type = &quot;l&quot;, xlim = c(0.0, 0.014), col = &quot;cyan&quot;) 6.2.3 Selecionar a carteira de Mínima Variância risk &lt;- sigma_c(alpha, sigma_i, rho_ij) min_var_weight &lt;- alpha[which.min(risk)] min_var_weight ## [1] 0.38 6.3 Montando uma carteira weights_c &lt;- c(BOVA11.SA = min_var_weight, SPXI11.SA = 1 - min_var_weight) port_1 &lt;- Return.portfolio(rets, weights_c, wealth.index = TRUE) plot(port_1) 6.3.1 O que acontece com os pesos dos ativos ao longo do tempo? Começamos a carteira com um \\(\\alpha\\) igual a 0.38. Logo temos 0.38 investidos em BOVA11 e 0.62 investidos em SPXI11. De acordo com a Eq.(6.1) as quantidades de cada ativo são atribuídos no instante da montagem da carteira, obedescendo pesos definidos. O que acontece se um ativo dobrar de valor e o outro ficar parado? Naturalmente os pesos dos ativos são alterados, pois as quantidades de cada ativo permanecem fixas. Logo, é necessário rebalancear a carteira para evitar que um ativo fique muito dominante na carteira, reduzindo a diversificação. Há diversas maneiras de fazer o rebalanceamento da carteira, uma forma bastante simples, embora não tanto eficaz, é fazer com que os ativos voltem a ponderação definida no instante inicial da carteira. Uma abordagem muito comum para investidores pessoa física é distribuir os ativos na carteira com pesos iguais e frequentemente fazer o rebalanceamento da carteira para enquadrar os pesos nesta regra. 6.4 Rebalanceamento da carteira weights_c &lt;- c(BOVA11.SA = min_var_weight, SPXI11.SA = 1 - min_var_weight) port_2 &lt;- Return.portfolio(rets, weights_c, rebalance_on = &quot;months&quot;, wealth.index = TRUE) ports &lt;- merge(port_1, port_2) %&gt;% `colnames&lt;-`(c(&quot;Sem rebalanceamento&quot;, &quot;Com rebalanceamento&quot;)) plot(ports, legend.loc = &quot;topleft&quot;) "]
]
